/// <reference types="node" />
import * as NodeStream from "stream";
import { Promise } from "ts-promise";
import { Stream, Readable } from "./Stream";
/**
 * Convert ts-stream into a Node.JS Readable instance.
 *
 * Usage example:
 * let sink = fs.createWriteStream("test.txt");
 * let tsSource = Stream.from(["abc", "def"]);
 * let source = new NodeReadable(tsSource);
 * source.pipe(sink);
 * sink.on("error", (error: Error) => tsSource.abort(error));
 * source.on("error", (error: Error) => { something like sink.destroy(); });
 *
 * @see `pipeToNodeStream()` for easier error and completion handling.
 */
export declare class NodeReadable<T> extends NodeStream.Readable {
    private _resumer;
    /**
     * Create new NodeJS Readable based on given ts-stream Readable.
     *
     * @see class description for usage example
     *
     * @param  tsReadable Source stream
     * @param  options    Optional options to pass to Node.JS Readable constructor
     */
    constructor(tsReadable: Readable<T>, options?: NodeStream.ReadableOptions);
    _read(size: number): void;
}
/**
 * Convenience wrapper around Node's file stream.
 *
 * Usage example:
 * let source = Stream.from(["abc", "def"]);
 * source.pipe(new FileSink("test.txt"));
 *
 * To wait for the stream's result, use e.g.
 * let sink = source.pipe(new FileSink("test.txt"));
 * sink.result().then(() => console.log("ok"), (err) => console.log("error", err));
 */
export declare class FileSink extends Stream<string> {
    /**
     * Construct writable ts-stream which writes all values to given file.
     * If the stream is ended with an error, the file is closed (and `result()`)
     * reflects that error.
     *
     * @see class description for usage example
     *
     * @param  path    Filename to wite to
     * @param  options Optional options (see https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options)
     */
    constructor(path: string, options?: {
        flags?: string;
        encoding?: string;
        string?: string;
    });
}
/**
 * Pipe a ts-stream ReadableStream to a Node.JS WritableStream.
 *
 * Reads all values from `tsReadable` and writes them to `nodeWritable`.
 * When readable ends, writable is also ended.
 *
 * If an error occurs on the writable stream, the readable stream is aborted
 * with that error.
 * If the readable stream is ended with an error, that error is optionally
 * emitted on the writable stream, and then the writable stream is ended.
 *
 * Usage example:
 * let sink = fs.createWriteStream("test.txt");
 * let source = Stream.from(["abc", "def"]);
 * let result = pipeToNodeStream(source, sink);
 * result.then(() => console.log("done"), (err) => console.log(err));
 *
 * @see `NodeReadable` if you need an instance of a Node.JS ReadableStream
 *
 * @param tsReadable   Source stream
 * @param nodeWritable Destination stream
 * @param emitError    Whether to emit errors in tsReadable on nodeWritable
 *                     (default false). Useful for e.g. destroying a socket
 *                     when an error occurs.
 * @return Promise that resolves when stream is finished (rejected when an error
 *         occurred)
 */
export declare function pipeToNodeStream<T>(tsReadable: Readable<T>, nodeWritable: NodeJS.WritableStream, emitError?: boolean): Promise<void>;
